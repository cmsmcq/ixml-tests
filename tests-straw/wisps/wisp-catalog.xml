<tc:test-catalog xmlns:tc="https://github.com/cmsmcq/ixml-tests"
		 name="Wisps test set 1"
		 release-date="2022-02-15" >
  <tc:description>
    <tc:p>Tests compiled manually in 2018 and 2019, re-packaged in 2022.</tc:p>
  </tc:description>
  <tc:description>
    <tc:p>Revisions:</tc:p>
    <tc:p>2022-02-09 : CMSMcQ : translate old test-strings document
    into test-catalog format</tc:p>
    <tc:p>2019-04-29 : CMSMcQ : copy to 2019, resume work collecting
    grammars from Grune and Jacobs.</tc:p>
    <tc:p>2018-08-21 : CMSMcQ : add more grammars.</tc:p>
    <tc:p>2018-04-06 : CMSMcQ : made first version of teststrings.xml,
    improvising an XML vocabulary for it.</tc:p>
  </tc:description>

  <tc:description>
    <tc:p>TO DO:</tc:p>
    <tc:p>Add test sets for grammars 70ff.</tc:p>
    <tc:p>Supply positive and negative test cases manually for each grammar.</tc:p>
    <tc:p>Create parse trees for positive test cases.</tc:p>
    <tc:p>For each grammar, create more systematic collections
    of positive and negative cases.</tc:p>
  </tc:description>
  


  <tc:test-set name="sample.grammar.01">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>The one used in the Balisage 2017 talk.</tc:p>
    </tc:description>

    <tc:ixml-grammar>E: E, Q, F; F.  F: 'a'; 'b'. Q: '+'; '-'.</tc:ixml-grammar>
    <tc:test-case name="g01.c01">
      <!-- <accept s="a"/> -->
      <tc:test-string>a</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E><F>a</F></E>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g01.cMM">
      <!-- <accept s="a+b"/> -->
      <tc:test-string>a+b</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g01.cMM">
      <tc:test-string>a-b+a</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g01.rMM">
      <tc:test-string>42</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g01.rMM">
      <tc:test-string>42</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g01.rMM">
      <tc:test-string>a*b/a</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g01.rMM">
      <tc:test-string>x-y+z</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g01.rMM">
      <tc:test-string>-a</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g01.rMM">
      <tc:test-string>a++</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g01.rMM">
      <tc:test-string>a-(b-a)</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.02">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>An attempt to force a prediction to be added after its
      completion when items are queued in the obvious way. Tests
      whether the parser handles the situation correctly; it can
      handle completion items repeatedly, or it can add null
      predictions earlier, or it can check each newly predicted item
      to see if it has already been completed.</tc:p>
    </tc:description>
    <tc:ixml-grammar>S: X, X. X: a. X: .</tc:ixml-grammar>
    <tc:test-case name="g02.cMM">
      <tc:test-string>
      </tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g02.cMM">
      <tc:test-string>a</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g02.cMM">
      <tc:test-string>aa</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g02.rMM">
      <tc:test-string>b</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g02.rMM">
      <tc:test-string>aaa</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.03">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A toy fragment of CSS from one of Steven Pemberton's talks.</tc:p>
    </tc:description>
    <tc:vxml-grammar-ref href="grammars/sample.grammar.03.ixml"/>
    <tc:test-case name="g03.cMM">
      <tc:test-string>p{}</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g03.cMM">
      <tc:test-string>p{a:x}</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g03.cMM">
      <tc:test-string>q{b:y;b2:z;xyz:x}</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g03.cMM">
      <tc:test-string>p{a:x}q{b:y;b2:z;xyz:x}</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g03.rMM">
      <tc:test-string>p</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g03.rMM">
      <tc:test-string>a:x</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g03.rMM">
      <tc:test-string>{a:x}</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g03.rMM">
      <tc:test-string>p{a x}</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g03.rMM">
      <tc:test-string>q{b:y;b2:z,xyz:x}</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g03.rMM">
      <tc:test-string>q{b:y;b2=z;xyz:x}</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g03.rMM">
      <tc:test-string>q{b:y b2:z xyz:x}</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g03.rMM">
      <tc:test-string>p{a:x};q{b:y;b2:z;xyz:x}</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.04">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>A more or less conventional grammar for four-operation
      arithmetic expressions over literal integers, from Loup
      Vaillant's tutorial on Earley parsing.</tc:p>
    </tc:description>
    <tc:vxml-grammar-ref href="grammars/sample.grammar.04.ixml"/>
    <tc:test-case name="g04.cMM">
      <tc:test-string>0</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.cMM">
      <tc:test-string>42</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.cMM">
      <tc:test-string>42-3</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.cMM">
      <tc:test-string>42*3-7</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.cMM">
      <tc:test-string>42-3/7</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.cMM">
      <tc:test-string>(42-3)/7</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.cMM">
      <tc:test-string>((42-3)/7)</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.cMM">
      <tc:test-string>((((42)-((3)))/7))</tc:test-string>
      <tc:result>
	<tc:assert-xml>
	  <E/>
	</tc:assert-xml>
      </tc:result>
    </tc:test-case>
    <!--* that last accept with nested parens takes 9 seconds
	to accept, with the version of Earley0 of 6 April 2018.
	That may be a sign.
	*-->
    <tc:test-case name="g04.rMM">
      <tc:test-string>x</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.rMM">
      <tc:test-string>-</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.rMM">
      <tc:test-string>-42</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.rMM">
      <tc:test-string>42=3</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.rMM">
      <tc:test-string>42-3div7</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.rMM">
      <tc:test-string>(42-3)/7)</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>
    <tc:test-case name="g04.rMM">
      <tc:test-string>(((42-3)/7)</tc:test-string>
      <tc:result>
	<tc:assert-not-a-sentence/>
      </tc:result>
    </tc:test-case>    
  </tc:test-set>
  
  <tc:test-set name="sample.grammar.05">
    <tc:created on="2022-02-08" by="cmsmcq"/>
    <tc:description>
      <tc:p>From Loup Vaillant, illustrating the same sequencing issue as
      grammar 2, I think.   Two versions in slightly different styles.</tc:p>
    </tc:description>
    <!-- <tc:ixml-grammar>A: . A: B. B: A.</tc:ixml-grammar> -->
    <tc:ixml-grammar>A: ; B. B: A.</tc:ixml-grammar>
  </tc:test-set>
  
    <tc:test-set name="sample.grammar.06">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Infinite parse trees without empty RHS.</tc:p>
      </tc:description>
      <tc:ixml-grammar>S: A; B. A: "a"; B. B: A; "b".</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.07">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Trivial left-recursive grammar, from Loup Vaillant and
	Grune/Jacobs.</tc:p>
      </tc:description>
      <tc:ixml-grammar>A: A, "a"; .</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.08">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Trivial right-recursive grammar, from Loup Vaillant and
	Grune/Jacobs. Unless they use Leo's optimization (or some
	other clever technique I haven't heard of), Earley parsers
	will take quadratic time and space on this.</tc:p>
      </tc:description>
      <tc:ixml-grammar>A: "a", A; .</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.09">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Toy if-then-else ambiguity from Loup Vaillant.</tc:p>
	<tc:p>Also illustrates use of character numbers.</tc:p>
      </tc:description>
      <tc:ixml-grammar>Block: "{}", S; If. If: "if", S, Block; "if", S, "else", S, Block.
	S: [" "; #0A; #0D; #09]*.</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.10">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Infinite ambiguity (loop).</tc:p>
      </tc:description>
      <tc:ixml-grammar>A: A; .</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.11">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Lots of infinite ambiguity.</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	S: (A; B; C)*.
	A: (A; B; C)*; ["x"; "y"; "z"]*.
	B: (A; B; C)*; ["x"; "y"; "z"]*.
	C: (A; B; C)*; ["x"; "y"; "z"]*.
      </tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.12">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Stripped down version of sample.grammar.11. Lots of
	ambiguity, but should be finite.</tc:p>
      </tc:description>
      <tc:ixml-grammar>S: A+.  A: (A, A)+; "a"+.</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.13">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>From Grune and Jacobs p. 201, discussion of "parsing by
	searching".  Lots of indeterminacy.</tc:p>
      </tc:description>
      <tc:ixml-grammar>S: "a", S, "b"; S, "a", "b"; "a", "a", "a".</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.14">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>From Grune and Jacobs p. 203, discussion of "parsing by
	searching".</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	S: E.
	E: E; E, Q, F.
	F: "a".
	Q: "+"; "-".
      </tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.15">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>From Grune and Jacobs p. 212, discussion of space and time
	requirements for Earley parsing.  A grammar "in
	which almost all non-terminal produce almost all substrings
	in almost all combinatorially possible ways".
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>S: S, S; "x".</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.16">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>From Grune and Jacobs p. 216; illustrates potential
	problems in closure algorithm when epsilon rules are
	present.</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	S: E.
	E: E, Q, F; F.
	F: "a".
	Q: "*"; "/"; .	  
      </tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.17">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>From Grune and Jacobs p. 217; grammar to illustrate the
	Aycock/Horspool optimization of Earley. Cf. grammar 2, but
	this one is shorter. Grune and Jacobs are pretty good at code
	golf for grammars!</tc:p>
      </tc:description>
      <tc:ixml-grammar>S: A, A, "x". A: .</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.18">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>From Grune and Jacobs p. 221, discussion of epsilon
	rules (here C, easy to overlook).</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	S: A; A, B; B.
	A: C.
	B: D.
	C: "p"; {nil} .
	D: "q".
      </tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.19">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Infinite ambiguity; based on sample.grammar.10 but without
	epsilon rule.</tc:p>
      </tc:description>
      <tc:ixml-grammar>A: A; "a".</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.20">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Infinite ambiguity, grows in width as well as depth.
	Based on sample.grammar.19.</tc:p>
      </tc:description>
      <tc:ixml-grammar>A: A, A; {nil} .</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.21">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Sample grammar from Joop Leo "A general context-free
	parsing algorithm running in linear time on every LR(k)
	grammar without using lookahead," Theoretical Computer Science
	82 (1991): 165-176.</tc:p>
	<tc:p>Illustrates right recursion and quadratic growth of items
	as reduction chains get longer and longer.</tc:p>
      </tc:description>
      <tc:ixml-grammar>S: "a", S; C. C: "a", C, "b"; {nil} .</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.22">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Infinite ambiguity in width, not depth. This cannot happen
	with BNF, only with EBNF. A test for the parse-tree extraction
	routine of an EBNF-capable Earley parser.</tc:p>
      </tc:description>
      <tc:ixml-grammar>S: (X)*. X: "x"; {nil}.</tc:ixml-grammar>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.23">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Another grammar with arbitrary width. This one illustrates
	that you can't just ignore empty nodes. Just one sentence, but
	infinitely many parse trees, all of rank 4 (document node, S,
	X, "x").</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	S: X.
	X:  A+, “x”, B+.
	A: {nil}. 
	B: {nil}.
      </tc:ixml-grammar>
      <tc:test-case name="g23.rMM">
	<tc:test-string>a</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g23.rMM">
	<tc:test-string>
	</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g23.cMM">
	<tc:test-string>x</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.24">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Another grammar with infinite ambiguity.
	This one illustrates the difficulty of trying to provide at least one
	parse  for each possible looping path through the tree.</tc:p>
	
	<tc:p>Consider a RHS that generates an infinite set of strings.
	By the pumping lemma for regular languages, we know that for
	every sentence longer than some language-dependent length
	(number of states in the FSA, if I remember correctly), the sentence
	takes the form uvw, where v can occur zero or more times, so
	u + v^n + w.</tc:p>
	<tc:p>It would be nice to illustrate the set of possible paths,
	just because. That is, for each set of paths through the RHS
	of the form u + v^n + w, provide paths for n=0 (u + w) and n=1
	(u + v + w).</tc:p>
	<tc:p>I don't see a convenient way to do this at the moment, so I
	currently plan to extend the notion of original NTs to regular
	languages (or see what H/U call this kind of thing) and return
	only original parses. But it would be interesting to see if
	one could exercise each loop in this FSA.</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	S: (A, ((B, (C, D)+, E)+, F)+, G)+.
	A: {nil}.  B: {nil}.  C: {nil}.  D: {nil}.  E: {nil}.  F: {nil}.  G: {nil}.
      </tc:ixml-grammar>
      <tc:test-case name="g24.rMM">
	<tc:test-string>a</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g24.rMM">
	<tc:test-string>
	</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g24.cMM">
	<tc:test-string>x</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.25">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Another grammar with infinite ambiguity.  This one
	has some non-terminals which occur only inside loops
	(so a ruthless policy of omitting all loops will never exhibit
	parse trees with them). </tc:p>
      </tc:description>
      <tc:ixml-grammar>
          S: A, B, C,
             D, (Z, C, D)*,
             E, (Y, B, C, D, (Z, C, D)*, E)*,
             F, (X, B, C, D, (Z, C, D)*, E, (Y, B, C, D, (Z, C, D)*, E)*, F )*,
             G, (W, A, B, C,
                D, (Z, C, D)*,
                E, (Y, B, C, D, (Z, C, D)*, E)*,
                F, (X, B, C, D, (Z, C, D)*, E, (Y, B, C, D, (Z, C, D)*, E)*, F )*, G)*.
          A: {nil}.  B: {nil}.  C: {nil}.  D: {nil}.  E: {nil}.  F: {nil}.  G: {nil}.
          Z: {nil}. Y: {nil}. X: {nil}. W: {nil}.
      </tc:ixml-grammar>
      <tc:test-case name="g25.rMM">
	<tc:test-string>a</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g25.cMM">
	<tc:test-string>
	</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g25.rMM">
	<tc:test-string>x</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.26">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Another grammar with infinite ambiguity.  Cut-down
	version of sample.grammar.25, with a single loop. </tc:p>
      </tc:description>
      <tc:ixml-grammar>
          S: A, B, (X, B)*, C.
          A: {nil}.  B: {nil}.  C: {nil}.  X: {nil}. 
      </tc:ixml-grammar>
      <tc:test-case name="g26.rMM">
	<tc:test-string>a</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g26.cMM">
	<tc:test-string>
	</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g26.rMM">
	<tc:test-string>x</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.27">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Another grammar with infinite ambiguity. This one shows
	that the problem of multiple non-trivial paths does not arise
	only horizontally with regular-right-part grammars, but can be
	created vertically as well; the set of derivations is the same
	as the set of paths through the right-hand side of S in
	sample.grammar.25.</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	S: A.
	{ The simple path with no loops. }
	A: B. B: C. C: D. D: E. E: F. F: G.
	{ The loops. }
	D: Z.  Z: C.
	E: Y.  Y: B.
	F: X.  X: B.	  
	G: W.  W: B.	  
	A: {nil}.  B: {nil}.  C: {nil}.  D: {nil}.  E: {nil}.  F: {nil}.  G: {nil}.
      </tc:ixml-grammar>
      <tc:test-case name="g27.rMM">
	<tc:test-string>a</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g27.rMM">
	<tc:test-string>
	</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g27.cMM">
	<tc:test-string>x</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.28">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Another grammar with infinite ambiguity. Vertical version
	of sample.grammar.26 and/or cut-down version of
	sample.grammar.27, with a single loop. </tc:p>
      </tc:description>
      <tc:ixml-grammar>
        S: A.  A: B.  B: C; X. X: B.
        A: {nil}.  B: {nil}.  C: {nil}.  X: {nil}. 
      </tc:ixml-grammar>
      <tc:test-case name="g28.rMM">
	<tc:test-string>a</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g28.cMM">
	<tc:test-string>
	</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g28.rMM">
	<tc:test-string>x</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.29">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Another grammar with arbitrary but minimum width. This one
	tries to break over-simple loop-detection algorithms; it's a
	variant of sample.grammar.23.</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	  S: X.
	  X:  A+, A+, "x".
	  A: {nil}. 
      </tc:ixml-grammar>
      <tc:test-case name="g29.rMM">
	<tc:test-string>a</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g29.rMM">
	<tc:test-string>
	</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g29.cMM">
	<tc:test-string>x</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.30">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>An attempt to isolate the bug caused by the initial version
	of sample.grammar.03 (toy CSS grammar).</tc:p>
	<tc:p>(Plan:  Play code golf.  Start with 03, cut the grammar
	down as long as we can while retaining the bug.)</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	name: ["a"-"z"]; ["a"-"z"].
      </tc:ixml-grammar>
      <tc:test-case name="g30.cMM">
	<tc:test-string>p</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.31">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>An attempt to isolate the bug caused by the initial version
	of sample.grammar.03 (toy CSS grammar).</tc:p>
	<tc:p>(Like 30, but the two branches are not identical.</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	name: ["a"-"z"]; ["a"-"z";"A"-"Z"].
      </tc:ixml-grammar>
      <tc:test-case name="g31.cMM">
	<tc:test-string>p</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <!--* OK, time to bootstrap *-->
    <!--* this is not numbered, but it occupies slot 32 *-->
    <!--
    <tc:test-set name="ixml.2016-08">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>The ixml grammar of August 2016, as I understand it.
	There are a number of open questions and probably some
	misunderstandings.</tc:p>
	<tc:p>The ixml itself is in ../lib (as is the master copy of the XML).</tc:p>
      </tc:description>
      <accept src="01" s="E: E, Q, F; F.  F: 'a'; 'b'. Q: '+'; '-'."/>
      <accept src="02" s="S: X, X. X: a. X: ."/>
      <accept src="05" s="A: . A: B. B: A."/>
      <accept src="05" s="A: ; B. B: A."/>
      <accept src="06" s="S: A; B. A: &quot;a&quot;; B. B: A; &quot;b&quot;."/>
      <accept src="07" s="A: A, &quot;a&quot;; ."/>
      <accept src="08" s="A: &quot;a&quot;, A; ."/>
      <accept src="09" s="Block: &quot;{}&quot;, S; If.
			  If: &quot;if&quot;, S, Block; &quot;if&quot;, S, &quot;else&quot;, S, Block.
      S: [&quot; &quot;; #0A; #0D; #09]*."/>
      <accept src="10" s="A: A; ."/>
      <accept src="11" s="
	S: (A; B; C)*.
	A: (A; B; C)*; [&quot;x&quot;; &quot;y&quot;; &quot;z&quot;]*.
	B: (A; B; C)*; [&quot;x&quot;; &quot;y&quot;; &quot;z&quot;]*.
	C: (A; B; C)*; [&quot;x&quot;; &quot;y&quot;; &quot;z&quot;]*.
	"/>
      <accept src="12" s="S: A+.  A: (A, A)+; &quot;a&quot;+."/>
      <accept src="13" s="S: &quot;a&quot;, S, &quot;b&quot;; S, &quot;a&quot;, &quot;b&quot;; &quot;a&quot;, &quot;a&quot;, &quot;a&quot;."/>
      <accept src="14" s="
	S: E.
	E: E; E, Q, F.
	F: &quot;a&quot;.
	Q: &quot;+&quot;; &quot;-&quot;.
      "/>
      <accept src="15" s="S: S, S; 'x'."/>
      <accept src="16" s="
	S: E.
	E: E, Q, F; F.
	F: &quot;a&quot;.
	Q: &quot;*&quot;; &quot;/&quot;; .	  
      "/>
      <accept src="17" s="S: A, A, &quot;x&quot;. A: ."/>
      <accept src="18" s="
	S: A; A, B; B.
	A: C.
	B: D.
	C: &quot;p&quot;; {nil} .
	D: &quot;q&quot;.
      "/>
      <accept src="19" s="A: A; &quot;a&quot;."/>
      <accept src="20" s="A: A, A; {nil} ."/>
      <accept src="21" s="S: &quot;a&quot;, S; C. C: &quot;a&quot;, C, &quot;b&quot;; {nil} ."/>
      <accept src="22" s="S: (X)*. X: &quot;x&quot;; {nil}."/>
      <accept src="23" s="
	S: X.
	X:  A+, 'x', B+.
	A: {nil}. 
	B: {nil}.
      "/>
      <accept src="24" s="
	S: (A, ((B, (C, D)+, E)+, F)+, G)+.
	A: {nil}.  B: {nil}.  C: {nil}.  D: {nil}.  E: {nil}.  F: {nil}.  G: {nil}.
      "/>
      <accept src="25" s="
          S: A, B, C,
             D, (Z, C, D)*,
             E, (Y, B, C, D, (Z, C, D)*, E)*,
             F, (X, B, C, D, (Z, C, D)*, E, (Y, B, C, D, (Z, C, D)*, E)*, F )*,
             G, (W, A, B, C,
                D, (Z, C, D)*,
                E, (Y, B, C, D, (Z, C, D)*, E)*,
                F, (X, B, C, D, (Z, C, D)*, E, (Y, B, C, D, (Z, C, D)*, E)*, F )*, G)*.
          A: {nil}.  B: {nil}.  C: {nil}.  D: {nil}.  E: {nil}.  F: {nil}.  G: {nil}.
          Z: {nil}. Y: {nil}. X: {nil}. W: {nil}.
      "/>
        <accept src="26" s="
          S: A, B, (X, B)*, C.
          A: {nil}.  B: {nil}.  C: {nil}.  X: {nil}. 
	"/>
      <accept src="27" s="
	S: A.
	{ The simple path with no loops. }
	A: B. B: C. C: D. D: E. E: F. F: G.
	{ The loops. }
	D: Z.  Z: C.
	E: Y.  Y: B.
	F: X.  X: B.	  
	G: W.  W: B.	  
	A: {nil}.  B: {nil}.  C: {nil}.  D: {nil}.  E: {nil}.  F: {nil}.  G: {nil}.
      "/>
      <accept src="28" s="
        S: A.  A: B.  B: C; X. X: B.
        A: {nil}.  B: {nil}.  C: {nil}.  X: {nil}. 
      "/>
      <accept src="29" s="
	  S: X.
	  X:  A+, A+, &quot;x&quot;.
	  A: {nil}. 
      "/>
      <accept src="30" s="
	name: [&quot;a&quot;-&quot;z&quot;]; [&quot;a&quot;-&quot;z&quot;].
      "/>
      <accept src="31" s="
	name: [&quot;a&quot;-&quot;z&quot;]; [&quot;a&quot;-&quot;z&quot;;&quot;A&quot;-&quot;Z&quot;].
      "/>
      <tc:test-case name="g31.rMM">
<tc:test-string>p</tc:test-string>
<tc:result>
<tc:assert-not-a-sentence/>
</tc:result>
</tc:test-case>
    </tc:test-set>
    *-->
    
    <tc:test-set name="sample.grammar.33">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Grammar for the toy programming language Tosca. </tc:p>
	<tc:p>From Susan Stepney, High integrity compilation: a case study. Hemel 
	Hempstead: Prentice Hall International, 1993. Web edition.  Tosca is 
	defined in chapter 4; the concrete syntax is specified using Z, not 
	using a grammar, and leaves some things undefined, so the grammar
	given here is a bit of a reconstruction.</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>
{ program is defined in section 4.8 }
program: decl*, cmd.

{ Names are described in 4.3 but left indeterminate syntactically;
I've made them like the SGML reference concrete syntax. }
NAME: letter, namechar*.
letter:  ["a"-"z"; "A"-"Z"].
digit: ["0"-"9"].
namechar:  letter; digit; ["-"; "."; "_"].

{ Types are described in 4.3 }
TYPE:  "int"; "bool".
boolean:  "true"; "false".
number:  digit+.

{ declarations:  section 4.4 }
decl:  NAME, S, ":", S, TYPE, S, ";", S.

{ operators, section 4.5 }
unaryOp: negate; not.  

negate: "-".
not: "not".

binaryOp: plus; minus; less; greater; equal; or; and.  
plus: "+".
minus: "-".
less: "&lt;".
greater: ">".
equal: "=".
or: "or".
and: "and".

{ expressions:  4.6 }
expr:  constant; variable; unaryExpr; binaryExpr.
constant:  number; boolean.
variable:  name.
unaryExpr:  unaryOp, S, expr.
binaryExpr:  "(", S, expr, S, binaryOp, S, expr, S, ")".

{ commands:  4.7 }
cmd: (skip; block; assign; choice; loop; input; output), S.
cmdseq: cmd*(";", S).
skip: "skip".
block:  "begin", S, cmdseq, "end".
assign: variable, S, ":=", S, expr.
choice: "if", S, expr, S, "then", S, cmd, "else", S, cmd.
loop: "while", S, expr, S, "do", S, cmd.
input: "input", S, name.
output: "output", S, expr.

{ Stepney does not specify whitespace or comment rules. }
-S: (ws; comment)*.
-ws: [#20; #0A; #09; #0D].
comment: "/*", nonstar*, ("*", nonstarnonslash*)*, "*/".
nonstar: ~["*"]. 
nonstarnonslash: ~["*"; "/"]. 

      </tc:ixml-grammar>
      <tc:test-case name="g33.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g33.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.34">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Sample grammar from Niklaus Wirth, Grundlagen und Techniken des 
	Compilerbaus (Bonn: Addison-Wesley, 1996, p. 5. 
	</tc:p>
	<tc:p>A finite language: L = ac, ad, bc, bd.
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	S: A, B.
	A: "a"; "b".
	B: "c"; "d".
      </tc:ixml-grammar>
      <tc:test-case name="g34.cMM">
	<tc:test-string>ac</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g34.cMM">
	<tc:test-string>ad</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g34.cMM">
	<tc:test-string>bc</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g34.cMM">
	<tc:test-string>bd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g34.rMM">
	<tc:test-string>abcd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g34.rMM">
	<tc:test-string>ab</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g34.rMM">
	<tc:test-string>ca</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.35">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Sample grammar from Niklaus Wirth, Grundlagen und Techniken des 
	Compilerbaus (Bonn: Addison-Wesley, 1996, p. 5. 
	</tc:p>
	<tc:p>An infinite language.
	L = empty string, a, aa, aaa, aaaa, ... 
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	S: A.
	A: "a", A; .
      </tc:ixml-grammar>
      <tc:test-case name="g35.cMM">
	<tc:test-string>
	</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g35.cMM">
	<tc:test-string>a</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g35.cMM">
	<tc:test-string>aa</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g35.cMM">
	<tc:test-string>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g35.rMM">
	<tc:test-string>b</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.36">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Sample grammar from Niklaus Wirth, Grundlagen und Techniken des 
	Compilerbaus (Bonn: Addison-Wesley, 1996, p. 6. 
	</tc:p>
	<tc:p>
	  An infinite language with center recursion.
	  L = b, abc, aabcc, aaabccc, ...
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	S: A.
	A: "a", A, "c"; "b".
      </tc:ixml-grammar>
      <tc:test-case name="g36.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g36.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.37">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Sample grammar from Niklaus Wirth, Grundlagen und Techniken des 
	Compilerbaus (Bonn: Addison-Wesley, 1996, p. 6. 
	</tc:p>
	<tc:p>Expressions. 
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	A: T; A, "+", T.
	T: F; T, "*", F.
	F: V; "(", A, ")".
	V: "a"; "b"; "c"; "d".
      </tc:ixml-grammar>
      <tc:test-case name="g37.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g37.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    

    <tc:test-set name="sample.grammar.38">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Sample grammar from Niklaus Wirth, Grundlagen und Techniken des
	Compilerbaus (Bonn: Addison-Wesley, 1996, p. 7.
	</tc:p>
	<tc:p>
	  Grammar for BNF as Wirth uses it.  Rules for ws added for
	  convenience; Wirth assumes the lexer eats whitespace.</tc:p>
	<tc:p>We write 'nil' for Wirth's empty-set symbol.</tc:p>
      </tc:description>
      <tc:ixml-grammar>
      syntax:  S?, production, syntax; nil.
      production: identifier, S?, "=", S?, expression, S?, ".", S?.
      expression: term; expression, S?, "|", S?, term.
      term: factor; term, S, factor.
      factor: identifer; string.

      identifier: letter; identifier, letter; identifier, digit.
      string: stringhead, '"'.
      stringhead: '"'; stringhead, character.
      letter: ["A"-"Z"; "a"-"z"].
      digit: ["0"-"9"].

      { Wirth does not define character. }
      character: ~['"'].

      { Wirth does not define empty-set symbol. }
      nil: .

      S: [" "; #09; #0A; #0D]+.
      </tc:ixml-grammar>
      <tc:test-case name="g38.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g38.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.39">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Sample grammar from Niklaus Wirth, Grundlagen und Techniken des
	Compilerbaus (Bonn: Addison-Wesley, 1996, p. 8.
	</tc:p>
	<tc:p>
	Grammar for EBNF as Wirth uses it.  Rules for ws added for
	convenience; Wirth assumes the lexer eats whitespace. 
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>
      syntax:  S?, production*S.
      production: identifier, S?, "=", S?, expression, S?, ".", S?.
      expression: term+("|", S?).
      term: factor+S.
      factor: identifer; string;
      "(", expression, ")";
      "[", expression, "]";
      "{", expression, "}".

      identifier: letter, (letter; digit)*.
      string: '"', character*, '"'.
      letter: ["A"-"Z"; "a"-"z"].
      digit: ["0"-"9"].

      { Wirth does not define character. }
      character: ~['"'].

      { Wirth does not define empty-set symbol. }
      nil: .

      S: [" "; #09; #0A; #0D]+.
      </tc:ixml-grammar>
      <tc:test-case name="g39.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g39.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.40">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>Sample grammar from Niklaus Wirth, Grundlagen und Techniken des
	Compilerbaus (Bonn: Addison-Wesley, 1996, p. 9.
	</tc:p>
	<tc:p>
	  EBNF as Wirth uses it.  Rules for ws added for convenience;
	  Wirth assumes the lexer eats whitespace. }
	</tc:p>
	<tc:p>Is this a duplicate of 39?</tc:p>
      </tc:description>
      <tc:ixml-grammar>
	
      syntax:  S?, production*S.
      production: identifier, S?, "=", S?, expression, S?, ".", S?.
      expression: term+("|", S?).
      term: factor+S.
      factor: identifer; string;
      "(", expression, ")";
      "[", expression, "]";
      "{", expression, "}".

      identifier: letter, (letter; digit)*.
      string: '"', character*, '"'.
      letter: ["A"-"Z"; "a"-"z"].
      digit: ["0"-"9"].

      { Wirth does not define character. }
      character: ~['"'].

      { Wirth does not define empty-set symbol. }
      nil: .

      S: [" "; #09; #0A; #0D]+.
      </tc:ixml-grammar>
      <tc:test-case name="g40.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g40.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.41">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	  Sample grammar from Niklaus Wirth, Grundlagen und Techniken des
	  Compilerbaus (Bonn: Addison-Wesley, 1996), pp. 36-37.
	</tc:p>
	<tc:p>
	  Oberon-0.
	</tc:p>
	<tc:p>	
	  Rules for ws added for convenience; Wirth assumes the lexer
	  eats whitespace.
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>
      { We move the rule for module to the front, since it is the
      start symbol. }

      module:
      S?, "MODULE", S,
      ident, S?, ";", S?,
      declarations,
      ("BEGIN", S, StatementSequence)?,
      "END", S?, ident, S?, ".", S?.
      ident:
      letter, (letter; digit)*, S?.
      integer:
      digit, (digit)*.

      selector:
      (".", S?, ident; "[", S?, expression, "]", S?)*.
      number:
      integer, S?.
      factor:
      ident, selector;
      number;
      "(", S?, expression, ")", S?;
      "~", S?, factor.
      term:
      factor+(("*"; "DIV"; "MOD"; "&amp;"), S?).
      SimpleExpression:
      ("+";"-")?, term+(("+";"-";"OR"), S?).
      { N.B. Simplexpression allows 1, -1, 1 + 1,
      -1 + 1, but not 1 + -1.
      I expect that's intentional.
      I've made it also forbid white space between sign and term.
      }    
      expression:
      SimpleExpression, ("="; "#"; "&lt;"; "&lt;="; "&gt;"; "&gt;="), SimpleExpression.
      assignment:
      ident, selector, ":=", S?, expression.
      ActualParameters:
      "(", S?, expression*(",", S?), ")", S?.
      ProcedureCall:
      ident, selector, ActualParameters?.
      IfStatement:
      "IF", S?, expression, "THEN", S?, StatementSequence,
      ("ELSIF", S?, expression, "THEN", S?, StatementSequence)*,
      "ELSE", S?, StatementSequence, "END", S?.
      WhileStatement:
      "WHILE", S?, expression, "DO", S?, StatementSequence, "END", S?.
      statement:
      (assignment; ProcedureCall; IfStatement; WhileStatement)?.
      StatementSequence:
      statement+(";", S?).

      IdentList:
      ident+(",", S?).
      ArrayType:
      "ARRAY", S?, expression, "OF", S?, type.
      FieldList:
      (IdentList, ":", S?, type)?.
      RecordType:
      "RECORD", S?, FieldList+(";", S?), "END", S?.
      type:
      ident; ArrayType; RecordType.
      FPSection:
      ("VAR")?, S, IdentList, ":", S?, type.
      FormalParameters:
      "(", S?, FPSection*(";", S?), ")", S?.
      ProcedureHeading:
      "PROCEDURE", S, ident, S?, FormalParameters?.
      ProcedureBody:
      declarations, ("BEGIN", S?, StatementSequence)?, "END", S, ident.
      ProcedureDeclaration:
      ProcedureHeading, ";", S?, ProcedureBody.
      declarations:
      ("CONST", S, (ident, "=", S?, expression, ";", S?)*)?,
      ("TYPE", S, (IdentList, "=", S?, type, ";")*)?,
      ("VAR", S, (IdentList, ":", S?, type, ";")*)?,
      ProcedureDeclaration*(";", S?).

      { S and comment added here to make the grammar usable without
      a scanner. N.B. Comments do not nest. }
      S: (ws; comment)+.
      ws: [" "; #09; #0A; #0D].
      comment: "(*", nonstar*, "*"+, (nonrpnonstar, nonstar*, "*"+)*, ")".
      nonstar: ~["*"].
      nonrpnonstar: ~[")"; "*"].</tc:ixml-grammar>
      <tc:test-case name="g41.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g41.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.42">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	  Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
	  Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
	  Second edition New York:  Springer, 2008), pp. 32 (1e) and 23 (2e).
	</tc:p>
	<tc:p>
	  Rules for ws added for convenience; Grune and Jacobs assume the lexer
	  eats whitespace.
	</tc:p>
      </tc:description>
      
      <tc:ixml-grammar>
      Sentence: Name; List, S, "and", S, Name.
      Name: "tom"; "dick"; "harry".
      List: Name, ", ", List; Name.

      S: " "+.

      { Generates

      tom
      dick
      tom and dick
      tom, dick and harry
      tom, tom, harry and dick

      Does not accept

      tom, dick, harry
      tom and dick and harry
      }</tc:ixml-grammar>
      <tc:test-case name="g42.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g42.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.43">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      Second edition New York:  Springer, 2008), pp. 33 (1e) and 26 (2e).

      Rules for ws added for convenience; Grune and Jacobs assume the lexer
      eats whitespace. Peculiarity:  whitespace is allowed but not required,
      and it is allowed after any keyword but not at the beginning of the input.

      }
      { Revisions:
      2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
      2018-08-10 : CMSMcQ : add pointer to 2e
      2018-08-09 : CMSMcQ : made first transcription; needs checking.
      }

      ZeroMotion: "up", S, ZeroMotion, "down", S, ZeroMotion;
      "down", S, ZeroMotion, "up", S, ZeroMotion;
      { nil }.

      S: [" "; #09; #A; #D]*.</tc:ixml-grammar>
      <tc:test-case name="g43.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g43.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.44">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      Second edition New York:  Springer, 2008), pp. 34 (1e) and 26 (2e).

      Rules for ws added for convenience; Grune and Jacobs assume the lexer
      eats whitespace. Peculiarity:  whitespace is allowed but not required,
      and it is allowed after any word but not at the beginning of the input. 
      }

      { Revisions:
      2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
      2018-08-10 : CMSMcQ : add pointer to 2e
      2018-08-09 : CMSMcQ : made first transcription; needs checking.
      }

      Sentence: Subject, Verb, Object.
      Subject: NounPhrase.
      Object: NounPhrase.
      NounPhrase: "the", S, QualifiedNoun.
      QualifiedNoun: Noun; Adjective, QualifiedNoun.
      Noun:  noun, S.
      Adjective: adjective, S.
      Verb: verb, S.
      noun: "castle"; "caterpillar"; "cats".
      adjective: "well-read"; "white"; "wistful".
      verb: "admires"; "bark"; "criticize".

      S: [" "; #09; #A; #D]*.

      { Produces, inter alia:

      the well-read cats criticize the wistful caterpillar
      the cats admires the white well-read castle

      }</tc:ixml-grammar>
      <tc:test-case name="g44.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g44.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.45">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      Second edition New York:  Springer, 2008), pp. 44 (1e) and 33 (2e).

      }

      { Revisions:
      2018-08-10 : CMSMcQ : add pointer to 2e
      2018-08-09 : CMSMcQ : made first transcription; needs checking.
      }

      Sentence: (( ["t"; "d"; "h"], ",")*, ["t"; "d"; "h"], "&amp;")?, ["t"; "d"; "h"].
      </tc:ixml-grammar>
      <tc:test-case name="g45.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g45.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.46">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      Second edition New York:  Springer, 2008), pp. 57 (1e) and 48 (2e).

      This is adapted / extended from the example in G and J's discussion of
      non-productive non-terminals.

      }

      { Revisions:
      2018-08-10 : CMSMcQ : add pointer to 2e
      2018-08-09 : CMSMcQ : made first transcription; needs checking.
      }


      S: "b"; X.
      X: "a", X.

      </tc:ixml-grammar>
      <tc:test-case name="g46.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g46.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.47">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      Second edition New York:  Springer, 2008), pp. 63 (1e) and 63 (2e).

      Caption is: "A simple ambiguous grammar."

      }

      { Revisions:
      2018-08-10 : CMSMcQ : add pointer to 2e
      2018-08-09 : CMSMcQ : made first transcription; needs checking.
      }

      Sum: Digit.
      Sum: Sum, "+", Sum.
      Digit:  ["0"-"9"].

      </tc:ixml-grammar>
      <tc:test-case name="g47.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g47.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.48">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      Second edition New York:  Springer, 2008), pp. 58 (1e) and 54 (2e).

      Caption is: "A grammar for sums of one-digit numbers."
      }

      { Revisions:
      2018-08-10 : CMSMcQ : add pointer to 2e
      2018-08-09 : CMSMcQ : made first transcription; needs checking.
      }

      Sum: Digit.
      Sum: Sum, "+", Digit.
      Digit:  ["0"-"9"].

      </tc:ixml-grammar>
      <tc:test-case name="g48.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g48.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.49">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      Second edition New York:  Springer, 2008), pp. 83 (1e) and 105 (2e).

      They use this grammar to illustrate Unger parsing.
      }

      { Revisions:
      2018-08-10 : CMSMcQ : add pointer to 2e
      2018-08-09 : CMSMcQ : made first transcription; needs checking.
      }

      Expr: Expr, "+", Term; Term.
      Term:  Term, "x" { or better yet [#00D7] = &amp;times; }, Factor; Factor.
      Factor: "(", Expr, ")"; "i".

      { e.g. "(i+i)xi" }

      </tc:ixml-grammar>
      <tc:test-case name="g49.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g49.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.50">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide
      (New York: Ellis Horwood, 1990), p. 86 (with typo),
      and second edition (New York:  Springer, 2008), p. 109
      (with typo corrected).

      They use this grammar to illustrate Unger parsing.
      "This grammar generates sequences of d's in an awkward way."
      }

      { Revisions:
      2018-08-09 : CMSMcQ : made first transcription.
      }

      S: L, S, D; .
      L: .
      D: "d".


      </tc:ixml-grammar>
      <tc:test-case name="g50.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g50.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.51">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 89 (1e) and 112 (2e).

      They use this grammar to illustrate CYK parsing.
      "This grammar describes the syntax of numbers in scientific notation."

      Versions of this grammar after elimination of epsilon-rules, 
      after eliminating unit rules, and after further cleanup (elimination
      of unreachable non-terminals) are given in pp. 120-122 of 2e.  I
      have not made test cases from them.  A Chomsky Normal Form equivalent
      is sample grammar 54.
      }

      { Revisions:
      2018-08-09 : CMSMcQ : made first transcription.
      }

      Number: Integer; Real.
      Integer: Digit; Integer, Digit.
      Real: Integer, Fraction, Scale.
      Fraction:  ".", Integer.
      Scale:  "e", Sign, Integer; Empty.
      Digit:  ["0"-"9"].
      Sign:  "+"; "-".
      Empty: .

      {e.g. 32.5e+1 }

      { Hmm.  Required sign for scale? }


      </tc:ixml-grammar>
      <tc:test-case name="g51.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g51.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.52">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 95 (1e) and 120 (2e).

      They use this grammar to illustrate grammar cleaning (in the course
      of their discussion of CYK parsing).

      "The grammar of Figure 4.10 [4.8 in 1e] is a nasty grammar to text
      your &amp;epsilon;-rule elimination scheme on."
      }

      { Revisions:
      2018-08-09 : CMSMcQ : made first transcription.
      }

      S: L, "a", M.
      L: L, M.
      L: .
      M: M, M.
      M: .

      </tc:ixml-grammar>
      <tc:test-case name="g52.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g52.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.53">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 96 (1e) and 120 (2e).

      They use this grammar to illustrate grammar cleaning (in the course
      of their discussion of CYK parsing); this is the result of applying
      their epsilon-rule elimination scheme to sample grammar 52.

      Its interest here is that it is an example of a machine-generated
      grammar and that it has non-productive and/or unreachable non-terminals.
      (Cleaning the grammar reduces it to the rule S: "a".)

      }

      { Revisions:
      2018-08-09 : CMSMcQ : made first transcription.
      }

      S: L1, "a", M1; "a", M1; L1, "a"; "a".
      L: L1, M1; L1; M1; {nil}.
      M: M1, M1; M1; {nil}.
      L1: L1, M1; L1; M1.
      M1: M1, M1; M1.


      </tc:ixml-grammar>
      <tc:test-case name="g53.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g53.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.54">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 99 (1e) and 123 (2e).

      This is a Chomsky Normal Form version of sample grammar 51; its
      primary interest for testing ixml parsers is its opacity.
      }

      { Revisions:
      2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
      2018-08-09 : CMSMcQ : made first transcription.
      }

      Number: ["0" - "9"].
      Number: Integer, Digit.
      Number: N1, Scale1;
      Integer, Fraction.
      N1:  Integer, Fraction.
      Integer:  ['0' - '9'].
      Integer:  Integer, Digit.
      Fraction: T1, Integer.
      T1 : ".".
      Scale1: N2, Integer.
      N2:  T2, Sign.
      T2:  "e".
      Digit: ['0'-'9'].
      Sign: ["+"; '-' ].

      </tc:ixml-grammar>
      <tc:test-case name="g54.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g54.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.55">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 109 (1e) and 142 (2e).

      This is a regular grammar; C/J use it in their discussion of parsing
      with regular grammars.
      }

      { Revisions:
      2018-08-09 : CMSMcQ : made first transcription.
      }

      S: "a", A; "a", B.
      A: "b", B.
      A: "b", C.
      B: "c", A.
      B: "c", C.
      C: "a".
      </tc:ixml-grammar>
      <tc:test-case name="g55.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g55.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.56">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 109 (1e) and 142 (2e).

      This is an augmented form of the regular grammar in 55, intended to
      illustrate the existence of undefined, unproductive, and unreachable
      non-terminals in regular grammars.
      }

      { Revisions:
      2018-08-09 : CMSMcQ : made first transcription.
      }

      S: "a", A; "a", B.
      A: "b", B.
      A: "b", C.
      B: "c", A.
      B: "c", C.
      C: "a".

      B: "c", D. { undefined }
      B: "c", E.
      E: "e", E. { unproductive }
      F: "f", A.  { unreachable }
      F: "h".


      </tc:ixml-grammar>
      <tc:test-case name="g56.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g56.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.57">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 119 (1e) and 165 (2e).

      "This grammar produces sentences with equal numbers of *a*s and *b*s."

      }

      { Revisions:
      2018-08-10 : CMSMcQ : made first transcription.
      }

      S: "a", B; "b", A.
      A: "a"; "a", S; "b", A, A.
      B: "b"; "b", S; "a", B, B.
      </tc:ixml-grammar>
      <tc:test-case name="g57.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g57.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.58">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), p. 49 (2e).

      "A demo grammar for grammar cleaning"
      }

      { Revisions:
      2018-08-10 : CMSMcQ : made first transcription.
      }

      S: A, B; D, E.
      A: "a".
      B: "b", C.
      C: "c".
      D: "d", F.
      E: "e".
      F: "f", D.

      { After removal of non-productive rules, this becomes

      S: A, B.
      A: "a".
      B: "b", C.
      C: "c".
      E: "e".

      E is now unreachable and its rule can be removed.

      }</tc:ixml-grammar>
      <tc:test-case name="g58.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g58.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.59">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), p. 49 (2e).

      "Grammar for an inherently ambiguous language"

      The language consists of all sequences a^m + b^n + c^n
      unioned with a^p + b^p + c^q.
      }

      { Revisions:
      2018-08-10 : CMSMcQ : made first transcription.
      }

      S: A, B; D, C.
      A: "a"; "a", A.
      B: "b", "c"; "b", B, "c".
      D: "a", "b"; "a", D, "b".
      C: "c"; "c", C.

      { sample grammar 60 is a recasting of this in idiomatic EBNF. }
      </tc:ixml-grammar>
      <tc:test-case name="g59.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g59.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.60">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), p. 49 (2e).

      "Grammar for an inherently ambiguous language"

      The language consists of all sequences a^m + b^n + c^n
      unioned with a^p + b^p + c^q.
      }

      { Revisions:
      2018-08-10 : CMSMcQ : made first transcription.
      }

      S: A, B; D, C.
      A: "a"+.
      B: "b", "c"; "b", B, "c".
      D: "a", "b"; "a", D, "b".
      C: "c"+.

      { This is a recasting of grammar 59 in idiomatic EBNF.
      Grune and Jacobs repeat this grammar (p. 171) and use it
      as an example when discussing general parsing methods.
      }
      </tc:ixml-grammar>
      <tc:test-case name="g60.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g60.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.61">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 167 (1e) and 238 (2e).

      "An example SLL(1) grammar"
      "This grammar generates all sentences starting with a number of
      as, followed by an equal number of bs."

      }

      { Revisions:
      2018-08-10 : CMSMcQ : made first transcription.
      }

      S: "a", B.
      B: "b"; "a", B, "b".
      </tc:ixml-grammar>
      <tc:test-case name="g61.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g61.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.62">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p></tc:p>
	<tc:p></tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 169 (1e) and 240 (2e).

      "The grammar describes a simple language that could be used as the 
      input language for a rudimentary consulting system; the user enters
      some facts, and then asks a question.  There is also a facility for
      sub-sesssions.  The contents of the facts and questions are of no
      concern here.  They are represented by the word STRING, which is
      regarded as a terminal symbol."

      I've simulated STRING by defining it as a line of characters
      ending with newline.

      }

      { Revisions:
      2018-08-10 : CMSMcQ : made first transcription.
      }

      Session:  Fact, Session.
      Session:  Question.
      Session:  "(", Session, ")", Session.
      Fact: "!", STRING.
      Question: "?", STRING.

      STRING: (~[#0A])*, [#0A].

      { Sample grammars 63 and 64 are rewrites of this grammar. }

      </tc:ixml-grammar>
      <tc:test-case name="g62.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g62.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.63">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p></tc:p>
	<tc:p></tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 170 (1e) and 242 (2e).

      This is G/J's rewrite of sample 62, using an epsilon rule for
      greater clarity.  Cf. also grammar 64.
      }

      { Revisions:
      2018-08-10 : CMSMcQ : made first transcription.
      }

      Session:  Facts, Question; "(", Session, ")", Session.
      Facts: Fact, Facts; {nil} .
      Fact: "!", STRING.
      Question: "?", STRING.

      STRING: (~[#0A])*, [#0A].

      { This and sample grammar 64 are rewrites of grammar 62. }

      </tc:ixml-grammar>
      <tc:test-case name="g63.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g63.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.64">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p></tc:p>
	<tc:p></tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 170 (1e) and 242 (2e).

      This is my rewrite of sample 63, using * instead of recursion in
      the definition of Facts.  (Session could also be

      Session:  (Fact)*, Question; "(", Session, ")", Session.
      
      but I believe this version is a little clearer.
      }

      { Revisions:
      2018-08-10 : CMSMcQ : correct syntax error found by DCG parser
      2018-08-10 : CMSMcQ : made first transcription.
      }

      Session:  Facts, Question; "(", Session, ")", Session.
      Facts: (Fact)*.
      Fact: "!", STRING.
      Question: "?", STRING.

      STRING: (~[#0A])*, [#0A].

      { This and sample grammar 62 are rewrites of grammar 62. }

      </tc:ixml-grammar>
      <tc:test-case name="g64.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g64.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.65">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 181 (1e) and 255 (2e).

      This is an LL(k+1) grammar that is not LL(k), where k = 3.
      The language itself, however, is not LL(4):  the same language is
      defined by S: "a","a","a", ("b";"c").
      }

      { Revisions:
      2018-08-10 : CMSMcQ : made first transcription.
      }

      S:  "a", "a", "a", "b"; "a", "a", "a", "c".



      </tc:ixml-grammar>
      <tc:test-case name="g65.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g65.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.66">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 181 (1e) and 255 (2e).

      This is an LL(k+1) language that is not LL(k), where k = 3.

      }

      { Revisions:
      2018-08-10 : CMSMcQ : made first transcription.
      }

      S:  ("a", S, A)?.
      A: "a", "a", "a", "b", S; "c".



      </tc:ixml-grammar>
      <tc:test-case name="g66.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g66.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.67">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar adapted from Dick Grune and Ceriel J. H. Jacobs,
      Parsing techniques: A practical guide (New York: Ellis Horwood, 1990;
      second edition New York:  Springer, 2008), pp. 182 (1e) and 255 (2e).

      "An LL(2) grammar that is not strong-LL(2)."

      }

      { Revisions:
      2018-08-10 : CMSMcQ : made first transcription.
      }

      S:  "a", A, "a", "a";
      "b", A, "b", "a".
      A: "b"; .



      </tc:ixml-grammar>
      <tc:test-case name="g67.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g67.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.68">
    <tc:created on="2022-02-08" by="cmsmcq"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar transcribed from Claus Braband, Robert Giegerich,
      and Anders M&amp;oslash;ller, "Analyzing Ambiguity of Context-Free Grammars."
      Science of Computer Programming 75.3 (2010): 176-191.

      https://www.itu.dk/people/brabrand/ambiguity-journal.pdf
      http://cs.au.dk/~amoeller/papers/ambiguity/journal.pdf

      The PDF gives no indication of publication venue.  The citation given
      appears to be confirmed by
      https://pub.uni-bielefeld.de/publication/1796697 and by Claus
      Braband's list of publications https://www.itu.dk/people/brabrand/

      A paper with the same authors and title (but apparently slightly
      different text) appeared in International Conference on Implementation
      and Application of Automata CIAA 2007, ed. Jan Holub, Jan
      &amp;Zhacek;d'&amp;aacute;rek (Springer), LNCS 4783, pp. 214-225.

      "A classical example of an unambiguous grammar that is not LR(k) (nor
      LR-Regular) is the following, called Pal, whose language consists of
      all palindromes over the alphabet {a, b}." (p. 9 Example 12 of PDF.)

      }

      { Revisions:
      2018-08-21 : CMSMcQ : made first transcription.
      }

      P: "a", P, "a"; "b", P, "b"; "a"; "b"; .



      </tc:ixml-grammar>
      <tc:test-case name="g68.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g68.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
    </tc:test-set>
    
    <tc:test-set name="sample.grammar.69">
      <tc:created by="cmsmcq" on="2022-02-08"/>
      <tc:description>
	<tc:p>
	</tc:p>
	<tc:p>
	</tc:p>
      </tc:description>
      <tc:ixml-grammar>{ Sample grammar transcribed from Claus Braband, Robert Giegerich,
      and Anders M&amp;oslash;ller, "Analyzing Ambiguity of Context-Free Grammars."
      Science of Computer Programming 75.3 (2010): 176-191.
      
      https://www.itu.dk/people/brabrand/ambiguity-journal.pdf
      http://cs.au.dk/~amoeller/papers/ambiguity/journal.pdf
      
      The PDF gives no indication of publication venue.  The citation given
      appears to be confirmed by
      https://pub.uni-bielefeld.de/publication/1796697 and by Claus
      Braband's list of publications https://www.itu.dk/people/brabrand/
      
      A paper with the same authors and title (but apparently slightly
      different text) appeared in International Conference on Implementation
      and Application of Automata CIAA 2007, ed. Jan Holub, Jan
      &amp;Zhacek;d'&amp;aacute;rek (Springer), LNCS 4783, pp. 214-225.
      
      "A variant of the grammar above [sc. sample grammar 68] is the
      following language, AntiPal, which our analysis also verifies to be
      unambiguous: ...  As we shall see in Section 8, this grammar is
      closely related to grammars occurring naturally in biosequence
      analysis."
      
      }
      
      { Revisions:
      2018-08-21 : CMSMcQ : made first transcription.
      }
      
      R: "a", R, "b"; "b", R, "a"; "a"; "b"; .
      </tc:ixml-grammar>
      <tc:test-case name="g69.cMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-xml>
	    <E/>
	  </tc:assert-xml>
	</tc:result>
      </tc:test-case>
      <tc:test-case name="g69.rMM">
	<tc:test-string>tbd</tc:test-string>
	<tc:result>
	  <tc:assert-not-a-sentence/>
	</tc:result>
      </tc:test-case>
  </tc:test-set>
</tc:test-catalog>
