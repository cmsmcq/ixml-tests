default namespace = "https://github.com/cmsmcq/ixml-tests"
namespace unqualified = ""

grammar {

	# RNC grammar for test catalog.
	#
	# Revisions:
	# 2021-10-31 : CMSMcQ : commit some changes:  @name on test-case,
	#                       allow at most one grammar for each test
	#                       set (grammars may be inherited from ancestor
	#                       test sets).
	# 2021-01-25 : CMSMcQ : sketch this out by hand.
        #
	# To do:
	# - add app-info (for insertion of arbitrary XML)
	# - add documentation links? 
	# - make description contents use div or paragraph-level HTML
	# - supply types for tokenized attributes?
	#

	

	start = test-catalog


	test-catalog = element test-catalog {
	    attribute name { text },
	    attribute release-date { xsd:date },
	    external-atts,
	    (metadata*
	    &
	    (test-set | test-set-ref)*)
	}

# Metadata

        metadata = description | app-info | doc

        description = element description {
	  external-atts,
	  p*
	}

        app-info = element app-info {
	  external-atts,
	  any-element*
	}

        doc = element doc {
	  external-atts,
	  attribute href { xsd:anyURI }
	}
	

# test-set

        test-set = element test-set {
	    attribute name { text },
	    external-atts,
	    (metadata*
	    &
	    (created,
	    modified*,
	    (ixml-grammar | vxml-grammar
	    | ixml-grammar-ref | vxml-grammar-ref)?,
	    grammar-test?,
	    (test-set | test-set-ref | test-case)*))
	}
        # Q. Why does test-set allow multiple grammars?
        # A. To avoid repetition.  If we want to run
	# tests both with an internal grammar, and
	# an external grammar, it's pointless to duplicate
	# the test set.  See tests-straw/gxxx for examples.
	#
	# The implicit assertion is that all grammars
	# given are equivalent.  A test run might
	# choose a convenient grammar (vxml over ixml)
	# or might run on all grammars.
	#
	# Counter-argument:  this complicates reporting
	# unnecessarily.  See test0.xml for an example
	# in which ixml-grammar and ixml-grammar-ref
	# are given different test cases.
	#
	# Counter-argument wins.  A test-set uses one grammar.  If
	# grammar. If none is specified, we get the grammar from the
	# ancestor.  If no ancestor specifies a grammar, we are
	# sunk.

        # name attribute should be required, is it?

	test-set-ref = element test-set-ref {
	    external-atts,
	    attribute href { xsd:anyURI }
	}

	# ixml-grammar:  grammar in invisible-XML form
	ixml-grammar = element ixml-grammar {
	    external-atts,
	    text
	}
	
	ixml-grammar-ref = element ixml-grammar-ref {
	    external-atts,
	    attribute href { xsd:anyURI }
	}

	# vxml-grammar:  grammar in visible-XML form
	# (either a parsed ixml grammar, translated into
	# XML, or something created in XML)
	#
	# N.B. we do not require a legal ixml grammar:
	# it may be a negative test case.
	vxml-grammar = element vxml-grammar {
	    external-atts,
	    any-element
	}
	
	vxml-grammar-ref = element vxml-grammar-ref {
	    external-atts,
	    attribute href { xsd:anyURI }
	}
	
	grammar-test = element grammar-test {
	    external-atts,
	    (metadata*
	    &
	    (created, modified*, result))
	}


# test-case

        test-case = element test-case {
	    attribute name { text }, 
	    external-atts,
	    (metadata*
	    &
	    (created, modified*,
	    (test-string | test-string-ref),
	    result)
	    )
	}
	# Need to require a name attribute.
	
	test-string = element test-string {
	    external-atts,
	    text
	}

	test-string-ref = element test-string-ref {
	    external-atts,
	    attribute href { xsd:anyURI }
	}
	
        result = element result {
	    external-atts,
	    assertion
	}


# Test assertions

        assertion = assert-xml-ref
	          | assert-xml
	          | assert-not-a-sentence

        assert-xml-ref = element assert-xml-ref {
	    external-atts,
	    attribute href { xsd:anyURI }
	}
        assert-xml = element assert-xml {
	    external-atts,
	    any-element+
	}
        assert-not-a-sentence = element assert-not-a-sentence {
	    external-atts,
	    metadata*
	}

# Common constructs

        who-when = attribute by { text },
	    	   attribute on { xsd:date }

        created = element created {
	    who-when
	}
        modified = element modified {
	    who-when,
	    attribute change { text }
	}

	p = element p { phrases }
	
	phrases = (text | emph | code)*

	emph = element emph { phrases }

        code = element code { text }

	anything = (any-element | any-attribute | text)* 
	any-element = element * { anything }
	any-attribute = attribute * { text }

        external-atts = nsq-att*

	nsq-att = attribute (* - unqualified:*) { text }

# Maintenance:
# To add a new kind of step, first add the name to 'step', then define an element with
# the appropriate parameters.

}